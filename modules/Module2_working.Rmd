---
title: "Module 2 Blanks"
output: html_document
date: "2025-08-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Module 2: Data Handling in R

This lesson is based on content from [Software Carpentry
* https://swcarpentry.github.io/r-novice-inflammation/01-starting-with-data.html
* https://datacarpentry.github.io/genomics-r-intro/05-dplyr.html
* https://datacarpentry.github.io/r-socialsci/03-dplyr.html
* https://datacarpentry.github.io/r-socialsci/04-tidyr.html
* https://mqwilber.github.io/2015-04-17-ucsb/lessons/intro_R_lessons/R_data_plotting_analysis.html
ChatGPT was used in the creation of examples and explanations.

### Objectives

By the end of this session, learners will be able to:
	*	Download data in Terminal to use in RStudio
	* Differentiate between data frames, lists, and matrices
	* Use base R to subset data
	* Use the dplyr package to manipulate dataframes.
  * Use select() to choose variables from a dataframe.
  * Use filter() to choose data based on values.
  * Use group_by() and summarize() to work with subsets of data.
  *Use mutate() to create new variables.

### Data frames, matrices, and lists

	* Data frame: most common tabular structure in R
	* List: collection of elements of different types
	* Matrix: 2D array of only one data type

```{r}

# Data frame
df <- data.frame(
  ID = 1:3,
  Name = c("Alice", "Bob", "Clara"),
  Age = c(34, 45, 29)
)

# List
patient <- list(
  ID = 101,
  Name = "David",
  Vitals = c(BP = 120, HR = 70),
  Notes = c("No allergies", "Nonsmoker")
)

# Matrix
mat <- matrix(1:9, nrow = 3, byrow = TRUE)

# Explore structure

```


### Set-up our environment

First, we need to load in the libraries we will use. Remember to go to Terminal to install new packages.

`conda install r-dplyr r-tidyr r-readr`

```{r}


#library(tidyverse)
#The tidyverse package is an “umbrella-package” that installs several packages useful for data analysis which work together well such as tidyr, dplyr, readr, ggplot2, tibble, etc. It can take some time to install, so do that later if you would like.
```

We are going to download example data from Software Carpentry. 

In Terminal, navigate to your directory.
`cd /mnt/work/workbench/<username>/`

Execute the commands to download from a URL
`wget https://swcarpentry.github.io/r-novice-inflammation/data/r-novice-inflammation-data.zip`

Unzip the data
`unzip r-novice-inflammation-data.zip`

Change directory into the new folder
`cd data`

List everything in the directory
`ls`

Now, let's read our data into R. 

I like to use the `data.table` package which has a function `fread()` and can be memory efficient for reading larger datasets. This creates a data.table object which has its own grammar for manipulating. 

The tidyverse has the `readr` package with the function `read_csv()`. This creates a tibble.

base R has the function `read.csv()` which creates a basic data frame.

```{r} 

username<-"YOUR USERNAME HERE"
path<-paste0("/mnt/work/workbench/",username,"/scratch/",username,"/data/")
path2<-paste0(path,"sample.csv")

#we pass 2 arguments, the path where the file is, and information about if the file has column names
#we assign the data frame information to the variable "dat"


#what do you think the col_names option does? how can we find out? what is the default parameter for header? what would happen if we did not use it?



#let's use base R because it's a little easier for beginners



```

Using `head` we see that R has auto-generated column names in the sequence V1 (for “variable 1”), V2, and so on, until V40. We will also inspect our data to get a sense of what it looks like.

```{r}




```

Each row holds the observations for just one patient. Each column holds values for several variables such as gender, blood pressure, and age.

For every column in the data frame, the function `summary` calculates: the minimum value, the first quartile, the median, the mean, the third quartile and the max value, giving helpful details about the sample distribution.

Like many programming languages, we can use indices to specify a certain row and column. The first value in brackets is row, and the second is column. R starts indices at 1, but some other langauges use 0, so be mindful of this.

If we want to select more than one row or column, we can use the function c, which combines the values you give it into one vector or list.

If we want to select contiguous rows or columns, we can use the colon.

```{r}

#this will pull out the value in the 30th row and 20th column


#let's check what 1:5 does


#now let's use it in row and column space


```

If we leave the row or column space open, it means we want to select all of that row or column.

```{r}

#All columns from row 3 to see the values for Sub003


# All rows from column 6-9 regarding Anuerysms


#what do you think happens if we leave both values empty


```

We can also use column names. This is helpful because if you add columns or rows later, the indices could change.

```{r}

#using the $ operator 


#Name within square brackets


#rows can have names too; in this case they're just the row index

```

All the indexing and subsetting that works on data frames also works on vectors.

```{r}

#pull out a column from the data frame as a vector


#subset for the first 10 participants


```

### dplyr and tidyr

Common dplyr verbs: `filter`, `select`, `mutate`, `summarize`, `group_by`
Check out the [dplyr cheatsheet](https://rstudio.github.io/cheatsheets/data-transformation.pdf)

Note: The packages in the tidyverse, namely dplyr, tidyr and ggplot2 accept both the British (e.g. summarise) and American (e.g. summarize) spelling variants of different function and option names.

#### filter() and select()
```{r}

#functionality similar to str()


#in dplyr we can select the columns by name


#another way to do this is with the pipe


# we can use filter to filter observations for individuals with high blood pressure, this time let's save it into a new data frame


# what object class is high


```

You may also have noticed that the output from the object `high` doesn’t run off the screen anymore. It’s one of the advantages of tbl_df (also called tibble), the central data class in the tidyverse, compared to normal dataframes in R.

```{r}
#you can see we went from 100 to 30 observations when we used filter()


# We can also specify multiple conditions within the filter() function.

#high blood pressure and the control group

# To form “and” statements within dplyr, we can pass our desired conditions as arguments in the filter() function, separated by commas:


# or we can use the ampersand "&" operator


#how can we check that both of these filtered data frames are the same size?

# Have you noticed that the Gender column uses two conventions for male/female (lower case and upper case)?


# To filter for the male participants, we will need to accomodate both conventions

# For an “or” statement, observations must meet at least one of the specified conditions. To form “or” statements we use the logical operator for “or,” which is the vertical bar (|):



```

# Pipes

What if we want to select and filter at the same time?

With intermediate steps, you create a temporary dataframe and use that as input to the next function.
You can also use nested functions (one function inside of another). R will evaluate the expression from the inside out.

Pipes let you take the output of one function and send it directly to the next, which is useful when you need to do many things to the same dataset. 

There are two Pipes in R: 
1) %>% (called magrittr pipe; made available via the magrittr package, installed automatically with dplyr)
2) |> (called native R pipe and it comes preinstalled with R v4.1.0 onwards). 
Both the pipes are, by and large, function similarly with a few differences.

Some may find it helpful to read the pipe like the word “then”. 

```{r}

#combining filter and select with a pipe


```

### mutate()

Frequently you’ll want to create new columns based on the values in existing columns, and for this you can use `mutate()`.

```{r}

#Let's fix the mismatched upper and lower case


# Is the new column there?


# We have to save this back to the "dat" object so the new column will be represented in future versions of the tibble


```


### group_by() and summarize()

Many data analysis tasks can be approached using the split-apply-combine paradigm: split the data into groups, apply some analysis to each group, and then combine the results. dplyr makes this very easy through the use of the `group_by()` function. `group_by()` is often used together with `summarize()`, which collapses each group into a single-row summary of that group.

```{r}

# What is the median blood pressure per treatment group?


# Can we also stratify by sex?


```

### count()

```{r}

#how many of each treatment group are there?


#let's sort by size


```

### long and wide data

A lot of data you will encounter is in a long format:
1) each column is a variable
2) each row is an observation
3) each value has its own cell
Long format is more machine readable and is closer to the formatting of databases.

Alternatively, in a “wide” data format we see modifications to rule 1, where each column no longer represents a single variable. Instead, columns can represent different levels/values of a variable. 

The columns Aneurisms_q1-Aneurisms_q4 are total number of aneurysms for both eyes in four different quadrants of the eye. We can think of this part of the data frame as being rather wide. If we wanted it to be longer, we would have just 2 columns, one being the quadrant number and one being the number of aneurysms in the quadrant. 

Two key functions in `tidyr` are `pivot_longer()` and `pivot_wider()`. [tidyr cheatsheet](https://rstudio.github.io/cheatsheets/tidyr.pdf)

pivot_longer() takes four principal arguments:

1) the data
2) cols are the names of the columns we use to fill the a new values variable (or to drop).
3) the names_to column variable we wish to create from the cols provided.
4) the values_to column variable we wish to create and fill with values associated with the cols provided.

```{r}


# what do you observe about the new data frame?

# now we can use group_by to summarize by quadrant, this would have been difficult in the previous format


```

We can think of the Group and BloodPressure columns of the dataset as being a long version of something that could be represented with a wide format. Let's test `pivot_wider` here.

pivot_wider() takes three principal arguments:

1) the data
2) the names_from column variable whose values will become new column names.
3) the values_from column variable whose values will fill the new column variables.

Further arguments include values_fill which, if set, fills in missing values with the value provided.

```{r}

# You see we have NA in the cells that are missing. This probably isn't a good data format for this dataset, but it may come in handy in other scenarios.

```

### Challenge

Task: Given a simple data frame of patients with ID, sex, age, and cholesterol values in two visits, write code to:
	1.	Filter patients over 45 years
	2.  Select ID and SBP columns
	3.	Create a new variable showing whether cholesterol is above 200. How many?
	4.	Summarize average cholesterol by sex

```{r}

df <- data.frame(
  ID = 1:8,
  Age = c(34, 60, 45, 50, 29, 80, 55, 65),
  SBP = c(120, 140, 135, 150, 110, 140, 120, 125 ),
  cholesterol = c(200,220, 190, 195, 180, 240, 230, 235),
  sex = c("Male","Male","Female","Male","Female","Female","Male","Male")
)

# Filter patients over 45

# Select specific columns

# Create a new variable (indicator variable) showing whether cholesterol is above 200

# Summarize average cholesterol by sex



```
